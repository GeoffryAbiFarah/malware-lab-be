# pip install pefile
# pip install capstone
# pip install requests
import sys
import pefile
from capstone import *

# 3 lists that can be used: pe_sections entry functions assembly
# pe_sections is a list of tuple of size 4

# verify the number of arguments
argc = len(sys.argv)
if (argc != 2):
    print("Usage: python {0} <file>".format(sys.argv[0]))
    exit(1)

# load and parse PE file
file = sys.argv[1]
print(file)
pe = pefile.PE(file)
print("\n File: {} loaded!\n".format(file))

# information from file PE fields
#print("Information about the different PE sections:\n")
pe_sections = []
for section in pe.sections:
    pe_sections.append((section.Name, hex(section.VirtualAddress), hex(
        section.Misc_VirtualSize), section.SizeOfRawData))

# lists the DLLs and function calls
#print("\nDLL and function calls:")
entry = []
functions = []
for e in pe.DIRECTORY_ENTRY_IMPORT:
    entry.append(e.dll)
    for function in e.imports:
        functions.append(function.name)


# linear disassembly
assembly = []
# get the address of the program entry point from the program header
entrypoint = pe.OPTIONAL_HEADER.AddressOfEntryPoint

# compute memory address where the entry code will be loaded into memory
entrypoint_address = entrypoint + pe.OPTIONAL_HEADER.ImageBase

# get the binary code from the PE file object
binary_code = pe.get_memory_mapped_image()[entrypoint:entrypoint + 100]

# initialize disassembler to disassemble 32 bit x86 binary code
disassembler = Cs(CS_ARCH_X86, CS_MODE_32)

# disassemble the code
for instruction in disassembler.disasm(binary_code, entrypoint_address):
    assembly.append("{0}\t{1}".format(
        instruction.mnemonic, instruction.op_str))


# print(assembly)

# sys.stdout.flush()
